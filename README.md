# Глобальный агрегатор ставок по депозитам (каркас)

Этот проект **собирает процентные ставки по депозитам** из разных источников (банки, агрегаторы, JSON API, HTML‑страницы, динамические сайты) и выводит **сводную таблицу** по валютам, **от большего процента к меньшему**.

> ⚠️ **Важно:** нет единого публичного API «всех банков мира». Поэтому проект построен как расширяемый каркас с конфигом `banks.yaml`. Вы добавляете источники (банки/агрегаторы), не нарушая их правил/robots.txt. В комплекте есть **демо-CSV**, чтобы вы могли сразу увидеть работу пайплайна.

## Быстрый старт

```bash
python -m venv .venv
. .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -r requirements.txt

# Браузер для Playwright (нужен только если используете тип источника playwright)
python -m playwright install chromium

python main.py
```

После запуска появятся файлы в `output/` вида `deposit_rates_YYYYMMDD_HHMMSS.csv` и `deposit_rates_YYYYMMDD_HHMMSS.md`.

## Как это работает

- `banks.yaml` — список источников.
  - `type: json` — тянем JSON и маппим поля.
  - `type: static_html` — парсим статическую HTML‑страницу по CSS‑селлекторам (+регэксп).
  - `type: playwright` — открываем динамический сайт (JS), ждём селектор, читаем таблицу.
  - `type: csv` — подключаем локальный CSV (например, выгрузка из Excel/Google Sheets).
- `scraper.py` — универсальный сборщик (requests/BS4/Playwright).
- `providers/base.py` — схема `DepositRecord`.
- `main.py` — агрегация, сортировка и сохранение результатов.

## Добавление новых банков

Откройте `banks.yaml` и добавьте новую запись. Примеры уже есть в файле:
- **JSON** c `json_map.list_path` и `fields`.
- **static_html** с CSS‑селекторами строк и полей, можно указать `regex` для выделения «5.2%» → `5.2`.
- **playwright** для динамических таблиц (`wait_for`, `rows_selector`, `fields`).
- **csv** — путь к вашему локальному CSV с колонками: `bank_name,country,currency,product,rate_apr,link,source`.

### Пример для статической таблицы

```yaml
- name: "Some Bank"
  country: "DE"
  currency_hint: ["EUR"]
  type: "static_html"
  url: "https://somebank.de/sparen/festgeld"
  html:
    rows:
      selector: "table.rates tbody tr"
    fields:
      bank_name: { value: "Some Bank" }
      product:   { selector: "td:nth-child(1)" }
      currency:  { value: "EUR" }
      rate_apr:  { selector: "td:nth-child(3)", regex: "(\d+[\.,]?\d*)\s*%" }
      link:      { selector: "a", attr: "href" }
```

## Сортировка и вывод

- Внутри валюты (`currency`) строки сортируются по `rate_apr` **по убыванию**.
- Экспорт в CSV и Markdown (разделами по валютам).

## Рекомендации по качеству данных

1. Проверяйте соответствие страны/валюты конкретному продукту (иногда на странице смешаны счета/сроки).
2. Для динамических сайтов увеличьте таймауты `wait_for` при медленной загрузке.
3. При парсинге **всегда** соблюдайте условия использования сайтов и их `robots.txt`.
4. Для промышленного использования добавьте:
   - Кэш/бекофф/ретраи,
   - Логику дедупликации,
   - Валидацию (мин/макс пороги ставок),
   - Прокси/ротацию User‑Agent,
   - Планировщик (cron) и базу данных (PostgreSQL/SQLite).

## Частые вопросы

**Почему не «все банки мира» из коробки?**  
У банков нет единого формата/АПИ; страницы часто меняются. Проект даёт *надёжную основу*, а полноту источников вы наращиваете конфигом.

**Можно ли сразу интегрировать Telegram‑бот?**  
Да, добавьте отправку файла в конце `main.py` через `python-telegram-bot` или HTTP‑загрузку в ваш чат.

---

© Вы можете свободно модифицировать и использовать этот каркас.
